% Copyright 2022 Jeffrey Kegler
% This document is licensed under
% a Creative Commons Attribution-NoDerivs 3.0 United States License.
\documentclass[12pt]{amsart}
\usepackage{url}
\usepackage{placeins}
\usepackage{needspace}

% We deal with underfull vbox's by eyeball, or not at all.
\raggedbottom

\newcommand{\dfn}[1]{{\bf #1}}
\newcommand{\mymathop}[1]{\mathop{\texttt{#1}}}
\newcommand{\V}[1]{\ensuremath{\texttt{\mbox{#1}}}}
\newcommand{\type}[1]{\ensuremath{\texttt{#1}}}
\newcommand{\tuple}[1]{\ensuremath{\left\langle #1 \right\rangle}}

\newcommand{\ah}[1]{#1_{\type{AH}}}
\newcommand{\Vah}[1]{\ensuremath{\V{#1}_{\type{AH}}}}
\newcommand{\dr}[1]{#1_{\type{DR}}}
\newcommand{\Vdr}[1]{\ensuremath{\V{#1}_{\type{DR}}}}
\newcommand{\orig}[1]{#1_{\type{ORIG}}}
\newcommand{\Vorig}[1]{\ensuremath{\V{#1}_{\type{ORIG}}}}

\newcommand{\GOTO}{\mymathop{GOTO}}
\newcommand{\Cfa}{\V{fa}}

\newsavebox{\myBox}
\newlength{\myHt}
\newlength{\myDp}
\newlength{\myWd}
\newcommand{\padBoxC}[3]{%
    \savebox{\myBox}{\ignorespaces#3}%
    \usebox{\myBox}%
    \myHt=\ht\myBox%
    \myDp=\dp\myBox%
    \vrule height\dimexpr\myHt+#1 depth\dimexpr\myDp+#2 width0pt%
}
\newcommand{\padBox}[2]{\padBoxC{#1}{#1}{#2}}

\newcommand{\cellboxWidth}[1]{4.5in}

% non-optional-argument version of cellbox
\newcommand{\cellboxB}[2]{%
    \parbox{#1}{\ignorespaces#2}%
}

% Padded cellbox
\newcommand{\cellbox}[2][\cellboxWidth]{%
    \cellboxB{#1}{%
        \padBoxC{4pt}{0pt}{\vphantom{(}}%
        {\ignorespaces#2}%
        \padBoxC{0pt}{4pt}{\vphantom{(}}%
    }%
}

\begin{document}

\date{\today}

\title{The Aycock-Horspool AHFA: some practical experience}

\author{Jeffrey Kegler}
\thanks{%
Copyright \copyright\ 2023 Jeffrey Kegler.  Version 1.
}
\thanks{%
This document is licensed under
a Creative Commons Attribution-NoDerivs 3.0 United States License.
}

\begin{abstract}
In the course of developing Marpa,
an Earley parser,
we implemented the
LR(0) state-based parsing described
in Aycock and Horspool's 2002 paper~\cite{AH2002}.
This allowed us to test its effectiveness in practice.
This paper reports our results.
\end{abstract}

\maketitle

\section{Overview}

The Marpa recognizer~\cite{Marpa2023} was intended
to make the best results on Earley's algorithm
in the academic literature available as
a practical general parser.
Accordingly, when it was first released in 2011,
it included the proposed improvements
in Aycock and Horspool's 2002 paper~\cite{AH2002}.
\cite{AH2002}~proposed changing Earley's algorithm to
collected dotted rules into states of a
finite automata.
In this paper a
``split LR(0) $\epsilon$-DFA''
as described by Aycock and Horspool~\cite{AH2002},
will be called an Aycock-Horspool Finite Automaton,
or AHFA.
Creating the AHFA was facilitated by a grammar rewrite
to eliminate properly nullable
(that is, nullable but not nulling)
symbols.

In 2014, we removed the AHFA state logic from
Marpa, but keep the associated grammar rewrite.
This paper explains why.

Readers should be familiar with Marpa~\cite{Marpa2023}
and Aycock and Horspool's 2002 paper~\cite{AH2002}.
Users of the current version of Marpa will find
this paper of historic interest, more than
direct relevance.
We hope that this paper would also
be of interest to researchers into
the relevance and usefulness of LR states in Earley parsing.

\section{ The Aycock-Horspool finite automata. }

This section will
summarize the ideas
from~\cite{AH2002}
that are central to Marpa.

Aycock and Horspool based their AHFA's
on a few observations.
\begin{itemize}
\item
In practice, Earley items sharing the same origin,
but having different dotted rules,
often appear together in the same Earley set.
\item
There is in the literature a method
for associating groups of dotted rules that often appear together
when parsing.
This method is the LR(0) DFA used in the much-studied
LALR and LR parsers.
\item
The LR(0) items that are the components of LR(0)
states are, exactly, dotted rules.
\item
By taking into account symbols that derive the
null string, the LR(0) DFA could be turned into an
LR(0) $\epsilon$-DFA,
which would be even more effective
at grouping dotted rules that often occur together
into a single DFA state.
\end{itemize}

AHFA states are, in effect,
a shorthand
for groups of dotted rules that occur together frequently.
Aycock and Horspool realized that,
by changing Earley items to track AHFA states
instead of individual dotted rules,
the size of Earley sets could be reduced,
and conjectured that this would
make Earley's algorithm faster in practice.

As a reminder,
the original Earley items (\type{EIMT}'s)
were duples,
$$\tuple{\Vdr{x}, \Vorig{x}},$$
where \Vdr{x} is a dotted rule.
An Aycock-Horspool Earley item is a duple
\begin{equation*}
\tuple{\Vah{y}, \Vorig{y}},
\end{equation*}
where $\Vah{y}$ is an AHFA state.

Marpa uses
Earley items of the form
created by Aycock and Horspool.
A Marpa Earley item has type \type{EIM},
and a Marpa Earley item is often referred to as an \type{EIM}.

\cite{AH2002} also defines
a partial transition function for
pairs of AHFA state and symbol,
\begin{equation*}
\GOTO: \Cfa, (\epsilon \cup \V{vocab}) \mapsto \Cfa.
\end{equation*}
$\GOTO(\Vah{from}, \epsilon)$ is a
\dfn{null transition}.
(AHFA's are not fully deterministic.)
If \Vah{predicted} is the result of a null transition,
it is called a \dfn{predicted} AHFA state.
If an AHFA state is not a \dfn{predicted} AHFA state,
it is called a \dfn{confirmed} AHFA state.
The initial AHFA state is a confirmed AHFA state.\footnote{%
In~\cite{AH2002} confirmed states are called ``kernel states'',
and predicted states are called ``non-kernel states''.
}

The states of an AHFA
are not a partition of the dotted
rules --
a single dotted rule can occur
in more than one AHFA state.
In combining
the improvements of Leo~\cite{Leo1991} and
Aycock and Horspool~\cite{AH2002},
the following theorem is crucial.
\section{The pitfall of counting Earley items}

In the Earley parsing literature speed results
are reported based on the count of Earley items -- the fewer Earley items, it is
assumed, the faster the parser. This totally ignores evaluation, never
mind tracing or run-time features like events.

This massive over-simplification worked, because Jay Earley and Joop
Leo only went for results in Landau notation, and these are "big" enough
that even a huge over-simplification is not a problem. This is not the
case when we are talking about a constant factor.

\section{AHFA states are not disjoint}

The relationship between AHFA items and Earley items is not
many-to-one, but many-to-many, greatly complicating the translation. IIRC
correctly this is not in their paper. I ran into it when
implementing.

We were able to measure the AHFA states for practical grammars, only to
find that their actual effect was quite small. The AHFA states did not
produce measurable improvements, and were serious obstacles to several
run-time features I was contemplating.

The problem of translating back and forth from LR rule sets to the grammar
is the most important factor that limited the success of LR parsing. When a Yacc parse
fails it is often very hard for the grammar writer to figure out why.

\section{ Statistics on AHFA states. }

\subsection{Confirmed states.}

\FloatBarrier

\begin{table}[ht]
\caption{
  \label{tab:perl-confirmed}
  Confirmed AHFA states for a Perl grammar}
\vspace{1ex}
\begin{tabular}{|r|r|}
\hline
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size}&
  \multicolumn{1}{|c|}{Percent}\\
& \multicolumn{1}{|c|}{of occurrences}\\
\hline
\rule{0pt}{2.3ex}
1&67.05\%\\
2&25.67\%\\
3&2.87\%\\
4&2.68\%\\
5&0.19\%\\
6&0.38\%\\
7&0.19\%\\
8&0.57\%\\
9&0.19\%\\
20&0.19\%\\
\hline
\end{tabular}
\end{table}

\FloatBarrier
\subsubsection{Confirmed states for a Perl grammar}
We show the counts for the confirmed states for the Perl grammar
in Table \ref{tab:perl-confirmed}
on page \pageref{tab:perl-confirmed}.
They range in size from 1 to 20 items,
but the numbers are heavily skewed toward the low
end.
As can be seen, well over 90\% of the total confirmed states have
just one or two items.
The average size is 1.5235,
and the average of the size squared is 3.9405.
\FloatBarrier

\begin{table}[ht]
\caption{
  \label{tab:html-confirmed}
  Confirmed AHFA states for HTML grammars}
\vspace{1ex}
\begin{tabular}{|r|r|}
\hline
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size}&
  \multicolumn{1}{|c|}{Percent}\\
& \multicolumn{1}{|c|}{of occurrences}\\
\hline
\rule{0pt}{2.3ex}
1&80.96\%\\
2&19.04\%\\
\hline
\end{tabular}
\end{table}

\FloatBarrier
\subsubsection{Confirmed states for HTML grammars}
For HTML, I looked at a parser which generates grammars on
the fly, aggregating the states in all of them.
The data are in
Table \ref{tab:html-confirmed}
on page \pageref{tab:html-confirmed}.
The average size is 1.1904,
and the average of the size squared is 1.5712.

\FloatBarrier % Necessary to make 'Needspace' below work
%             % to prevent orphan
\begin{table}[ht]
\caption{
  \label{tab:c-confirmed}
  Confirmed AHFA states for a C grammar}
\vspace{1ex}
\begin{tabular}{|r|r|}
\hline
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size}&
  \multicolumn{1}{|c|}{Occurrences}\\
\hline
\rule{0pt}{2.3ex}
1&695\\
2&188\\
3&40\\
4&17\\
5&6\\
6&8\\
7&6\\
8&4\\
9&1\\
10&2\\
12&2\\
15&1\\
\hline
\end{tabular}
\end{table}

\FloatBarrier
Table \ref{tab:c-confirmed}
on page \pageref{tab:c-confirmed}
shows the count of confirmed AHFA states, by state size,
for a compiler-quality C grammar,
the confirmed states range in size from 1 to 15 items but again,
the numbers are heavily skewed toward the low
end.  Here are the item counts that appear, with the percent of the total
confirmed AHFA states with that item count in parentheses.
There were 970 confirmed C states.
The average size was 1.52.
The average of the size squared was 3.98.
\FloatBarrier

\subsection{Predicted states.}

The number of predicted states tends to be much more
evenly distributed.
It also tends to be much larger, and
the average for practical grammars may be $O(s)$,
where $s$ is the size of the grammar.
This is the same as the theoretical worst case.
For predicted states, because AHFA states of varied
size are common,
we switch from showing the frequency of AHFA states
for each size,
to showing the sizes of the AHFA state by the
frequency of states of that size.

\FloatBarrier
\begin{table}[ht]
\caption{
  \label{tab:perl-predicted}
  Predicted AHFA states for a Perl grammar}
\vspace{1ex}
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size of AHFA state}&
  \multicolumn{1}{|c|}{Occurrences of states}\\
   &\multicolumn{1}{|c|}{of that size}\\
\hline
\rule{0pt}{2.3ex}%
2&5\\
\hline
\rule{0pt}{2.3ex}%
3, 142&4\\
\hline
\rule{0pt}{2.3ex}%
1, 4&3\\
\hline
\rule{0pt}{2.3ex}%
6, 7, 143&2\\
\hline
\cellbox[3in]{
  5, 64, 71, 77, 79, 81, 83, 85, 88, 90, 98, 100, 102,
  104, 106, 108, 111, 116, 127, 129, 132, 135, 136, 137, 141,
  144, 149, 151, 156, 157, 220, 224, 225
}
  &1\\
\hline
\end{tabular}
\end{table}

\FloatBarrier
\subsubsection{Predicted states for a Perl grammar}

Table \ref{tab:perl-predicted}
on page \pageref{tab:perl-predicted}
shows the data for a Perl grammar.
The number of predicted states in the Perl grammar was 58.
The average size was 83.59 AHFA items.
The average of the size squared was 11356.41.
\FloatBarrier

\begin{table}[ht]
\caption{
  \label{tab:html-predicted}
  Predicted AHFA states for HTML grammars}
\vspace{1ex}
\begin{tabular}{|r|r|c|r|r|}
\cline{1-2} \cline{4-5}
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size}&
  \multicolumn{1}{|c|}{Occurrences}&
  \multicolumn{1}{|c|}{}&
\multicolumn{1}{|c|}{Size}&
  \multicolumn{1}{|c|}{Occurrences}\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
1&95&&
20&190\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
2&95&&
21&63\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
4&95&&
22&22\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
11&181&&
24&8\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
14&181&&
25&16\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
15&294&&
26&16\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
16&112&&
28&2\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
18&349&&
29&16\\
\cline{1-2} \cline{4-5}
\rule{0pt}{2.3ex}%
19&120\\
\cline{1-2}
\end{tabular}
\end{table}

\FloatBarrier
\subsubsection{Predicted states for HTML grammars}

Data for predicted AHFA states in the HTML grammars
is in Table \ref{tab:html-predicted}
on page \pageref{tab:html-predicted}.
The total number of predicted states in the HTML grammars was
1855. Their average size was 14.60. Their average size squared was
250.93.
\FloatBarrier

\begin{table}[ht]
\caption{
  \label{tab:c-predicted}
  Predicted AHFA states for a C grammar}
\vspace{1ex}
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}
  {\rule{0pt}{2.3ex}
   \rule{0pt}{-.5ex}
   Size of AHFA state}&
  \multicolumn{1}{|c|}{Occurrences of states}\\
   &\multicolumn{1}{|c|}{of that size}\\
\hline
\rule{0pt}{2.3ex}%
2, 3&6\\
\hline
\rule{0pt}{2.3ex}%
8&5\\
\hline
\rule{0pt}{2.3ex}%
4, 90&4\\
\hline
\rule{0pt}{2.3ex}%
6, 11, 31, 47&3\\
\hline
\rule{0pt}{2.3ex}%
\cellbox[3in]{5, 14, 42, 64, 68, 78, 91, 95, 98}
&2\\
\hline
\cellbox[3in]{
1, 7, 9, 12, 15, 17, 18, 19, 21, 22, 25, 28, 29, 33, 34, 36,
37, 40, 43, 44, 45, 46, 52, 53, 54, 57, 58, 61, 65, 66, 69, 72,
74, 76, 80, 81, 86, 87, 89, 94, 96, 97, 99, 102, 105, 108,
115, 117, 119, 123, 125, 127, 144, 149, 150, 154, 181, 219,
222.
}
  &1\\
\hline
\end{tabular}
\end{table}

\FloatBarrier
\subsubsection{Predicted states for a C grammar}

The data for predicted states in a C grammar
is Table \ref{tab:c-predicted}
on page \pageref{tab:c-predicted}
The number of predicted states in the C grammar was 114.
The average size was 54.81.
The average size squared was 5361.28.
The sizes of the predicted states for the C grammar were spread from 1
to 222.
\FloatBarrier

\subsection{Completed LHS symbols per AHFA state. }
An AHFA state may contain completions for more than one LHS,
but that is rare in practical use, and the number of completed
LHS symbols in the exceptions remains low.
The very complex Perl AHFA contains 271 states with completions.
Of these 268 have only one completed symbol.
The other three AHFA states complete only two different LHS symbols.
Two states have completions with both
a \texttt{term\_hi} and an \texttt{indirob} on the LHS.
One state has completions for both a
\texttt{sideff} and an \texttt{mexpr}.

My HTML test grammars make the
same point more strongly.
My HTML parser generates grammars on the fly.
These HTML grammars can differ from each other.
because Marpa takes the HTML input into account when
generating the grammar.
In my HTML test suite,
every single one
of the 14,782 AHFA states
has only one completed LHS symbol.

\FloatBarrier

\bibliographystyle{plain}

\begin{thebibliography}{10}

\raggedright

\bibitem{AU1972}
Alfred H.~Aho and Jeffrey D.~Ullman.
\newblock The Theory of Parsing, Translation, and Computing
\newblock Prentice-Hall, Englewood Cliff, N.J., 1972.

\bibitem{AH2002}
John~Aycock and R.~Nigel~Horspool.
\newblock Practical Earley Parsing
\newblock {\em The Computer Journal},
    Vol. 45, No. 6, 2002, pp. 620-630.

\bibitem{Earley1970}
J.~Earley.
\newblock An efficient context-free parsing algorithm.
\newblock {\em Communications of the Association for Computing Machinery},
  13(2):94--102, 1970.

\bibitem{GJ2008}
Dirk~Grune and Ceriel~J.H Jacobs.
\newblock {\em Parsing Techniques: A Practical Guide}.
\newblock Springer, Amsterdam, 2008.

\bibitem{Marpa2023}
Jeffrey~Kegler.
\newblock Marpa, A practical general parser: the recognizer.
\\ % fix underfull HBOX
\newblock arXiv:1910.08129.
\newblock \url{https://arxiv.org/abs/1910.08129}

\bibitem{Marpa-R2}
Jeffrey~Kegler, 2013: Marpa-R2.
\newblock \url{http://search.cpan.org/dist/Marpa-R2/}.

\bibitem{Leo1991}
J.~M. I.~M. Leo.
\newblock A general context-free parsing algorithm running in linear time on
  every {LR($k$)} grammar without using lookahead.
\newblock {\em Theoretical Computer Science}, 82:165--176, 1991.

\end{thebibliography}

\clearpage
\tableofcontents

\end{document}
